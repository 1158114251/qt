// This file was generated by qlalr - DO NOT EDIT!

#line 95 "qmljs.g"

/****************************************************************************
**
** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
** Contact: Qt Software Information (qt-info@nokia.com)
**
** This file is part of the QtScript module of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:LGPL$
** No Commercial Usage
** This file contains pre-release code and may not be distributed.
** You may use this file in accordance with the terms and conditions
** contained in the either Technology Preview License Agreement or the
** Beta Release License Agreement.
**
** GNU Lesser General Public License Usage
** Alternatively, this file may be used under the terms of the GNU Lesser
** General Public License version 2.1 as published by the Free Software
** Foundation and appearing in the file LICENSE.LGPL included in the
** packaging of this file.  Please review the following information to
** ensure the GNU Lesser General Public License version 2.1 requirements
** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
** In addition, as a special exception, Nokia gives you certain
** additional rights. These rights are described in the Nokia Qt LGPL
** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
** package.
**
** GNU General Public License Usage
** Alternatively, this file may be used under the terms of the GNU
** General Public License version 3.0 as published by the Free Software
** Foundation and appearing in the file LICENSE.GPL included in the
** packaging of this file.  Please review the following information to
** ensure the GNU General Public License version 3.0 requirements will be
** met: http://www.gnu.org/copyleft/gpl.html.
**
** If you are unsure which license is appropriate for your use, please
** contact the sales department at qt-sales@nokia.com.
** $QT_END_LICENSE$
**
****************************************************************************/

#include <QtCore/QtDebug>

#include <string.h>

#include "qmljsengine_p.h"
#include "qmljslexer_p.h"
#include "qmljsast_p.h"
#include "qmljsnodepool_p.h"


#line 349 "qmljs.g"


#include "qmljsparser_p.h"
#include <QVarLengthArray>

//
// This file is automatically generated from qmljs.g.
// Changes will be lost.
//

using namespace QmlJS;

QT_BEGIN_NAMESPACE

void Parser::reallocateStack()
{
    if (! stack_size)
        stack_size = 128;
    else
        stack_size <<= 1;

    sym_stack = reinterpret_cast<Value*> (qRealloc(sym_stack, stack_size * sizeof(Value)));
    state_stack = reinterpret_cast<int*> (qRealloc(state_stack, stack_size * sizeof(int)));
    location_stack = reinterpret_cast<AST::SourceLocation*> (qRealloc(location_stack, stack_size * sizeof(AST::SourceLocation)));
}

inline static bool automatic(Engine *driver, int token)
{
    return token == QmlJSGrammar::T_RBRACE
        || token == 0
        || driver->lexer()->prevTerminator();
}


Parser::Parser(Engine *engine):
    driver(engine),
    tos(0),
    stack_size(0),
    sym_stack(0),
    state_stack(0),
    location_stack(0),
    first_token(0),
    last_token(0)
{
}

Parser::~Parser()
{
    if (stack_size) {
        qFree(sym_stack);
        qFree(state_stack);
        qFree(location_stack);
    }
}

static inline AST::SourceLocation location(Lexer *lexer)
{
    AST::SourceLocation loc;
    loc.offset = lexer->tokenOffset();
    loc.length = lexer->tokenLength();
    loc.startLine = lexer->startLineNo();
    loc.startColumn = lexer->startColumnNo();
    return loc;
}

AST::UiQualifiedId *Parser::reparseAsQualifiedId(AST::ExpressionNode *expr)
{
    QVarLengthArray<NameId *, 4> nameIds;
    QVarLengthArray<AST::SourceLocation, 4> locations;

    AST::ExpressionNode *it = expr;
    while (AST::FieldMemberExpression *m = AST::cast<AST::FieldMemberExpression *>(it)) {
        nameIds.append(m->name);
        locations.append(m->identifierToken);
        it = m->base;
    }

    if (AST::IdentifierExpression *idExpr = AST::cast<AST::IdentifierExpression *>(it)) {
        AST::UiQualifiedId *q = makeAstNode<AST::UiQualifiedId>(driver->nodePool(), idExpr->name);
        q->identifierToken = idExpr->identifierToken;

        AST::UiQualifiedId *currentId = q;
        for (int i = nameIds.size() - 1; i != -1; --i) {
            currentId = makeAstNode<AST::UiQualifiedId>(driver->nodePool(), currentId, nameIds[i]);
            currentId->identifierToken = locations[i];
        }

        return currentId->finish();
    }

    return 0;
}

bool Parser::parse()
{
    Lexer *lexer = driver->lexer();
    bool hadErrors = false;
    int yytoken = -1;
    int action = 0;

    first_token = last_token = 0;

    tos = -1;
    program = 0;

    do {
        if (++tos == stack_size)
            reallocateStack();

        state_stack[tos] = action;

    _Lcheck_token:
        if (yytoken == -1 && -TERMINAL_COUNT != action_index[action]) {
            yyprevlloc = yylloc;

            if (first_token == last_token) {
                yytoken = lexer->lex();
                yylval = lexer->dval();
                yylloc = location(lexer);
            } else {
                yytoken = first_token->token;
                yylval = first_token->dval;
                yylloc = first_token->loc;
                ++first_token;
            }
        }

        action = t_action(action, yytoken);
        if (action > 0) {
            if (action != ACCEPT_STATE) {
                yytoken = -1;
                sym(1).dval = yylval;
                loc(1) = yylloc;
            } else {
              --tos;
              return ! hadErrors;
            }
        } else if (action < 0) {
          const int r = -action - 1;
          tos -= rhs[r];

          switch (r) {

#line 498 "qmljs.g"

case 0: {
  program = makeAstNode<AST::UiProgram> (driver->nodePool(), sym(1).UiImportList,
        sym(2).UiObjectMemberList->finish());
  sym(1).UiProgram = program;
} break;

#line 508 "qmljs.g"

case 2: {
    sym(1).Node = sym(1).UiImportList->finish();
} break;

#line 515 "qmljs.g"

case 3: {
    sym(1).Node = makeAstNode<AST::UiImportList> (driver->nodePool(), sym(1).UiImport);
} break;

#line 522 "qmljs.g"

case 4: {
    sym(1).Node = makeAstNode<AST::UiImportList> (driver->nodePool(),
        sym(1).UiImportList, sym(2).UiImport);
} break;

#line 531 "qmljs.g"

case 6: {
    AST::UiImport *node = makeAstNode<AST::UiImport>(driver->nodePool(), sym(2).sval);
    node->importToken = loc(1);
    node->fileNameToken = loc(2);
    node->semicolonToken = loc(3);
    sym(1).Node = node;
} break;

#line 543 "qmljs.g"

case 8: {
    AST::UiImport *node = makeAstNode<AST::UiImport>(driver->nodePool(), sym(2).sval);
    node->importId = sym(4).sval;
    node->importToken = loc(1);
    node->fileNameToken = loc(2);
    node->asToken = loc(3);
    node->importIdToken = loc(4);
    node->semicolonToken = loc(5);
    sym(1).Node = node;
} break;

#line 558 "qmljs.g"

case 10: {
    AST::UiImport *node = makeAstNode<AST::UiImport>(driver->nodePool(), sym(2).UiQualifiedId->finish());
    node->importToken = loc(1);
    node->fileNameToken = loc(2);
    node->semicolonToken = loc(3);
    sym(1).Node = node;
} break;

#line 570 "qmljs.g"

case 12: {
    AST::UiImport *node = makeAstNode<AST::UiImport>(driver->nodePool(), sym(2).UiQualifiedId->finish());
    node->importToken = loc(1);
    node->fileNameToken = loc(2);
    node->versionToken = loc(3);
    node->semicolonToken = loc(4);
    sym(1).Node = node;
} break;

#line 583 "qmljs.g"

case 14: {
    AST::UiImport *node = makeAstNode<AST::UiImport>(driver->nodePool(), sym(2).UiQualifiedId->finish());
    node->importId = sym(5).sval;
    node->importToken = loc(1);
    node->fileNameToken = loc(2);
    node->versionToken = loc(3);
    node->asToken = loc(4);
    node->importIdToken = loc(5);
    node->semicolonToken = loc(6);
    sym(1).Node = node;
} break;

#line 599 "qmljs.g"

case 16: {
    AST::UiImport *node = makeAstNode<AST::UiImport>(driver->nodePool(), sym(2).UiQualifiedId->finish());
    node->importId = sym(4).sval;
    node->importToken = loc(1);
    node->fileNameToken = loc(2);
    node->asToken = loc(3);
    node->importIdToken = loc(4);
    node->semicolonToken = loc(5);
    sym(1).Node = node;
} break;

#line 613 "qmljs.g"

case 17: {
    sym(1).Node = 0;
} break;

#line 620 "qmljs.g"

case 18: {
    sym(1).Node = makeAstNode<AST::UiObjectMemberList> (driver->nodePool(), sym(1).UiObjectMember);
} break;

#line 627 "qmljs.g"

case 19: {
    sym(1).Node = makeAstNode<AST::UiObjectMemberList> (driver->nodePool(), sym(1).UiObjectMember);
} break;

#line 634 "qmljs.g"

case 20: {
    AST::UiObjectMemberList *node = makeAstNode<AST:: UiObjectMemberList> (driver->nodePool(),
        sym(1).UiObjectMemberList, sym(2).UiObjectMember);
    sym(1).Node = node;
} break;

#line 643 "qmljs.g"

case 21: {
    sym(1).Node = makeAstNode<AST::UiArrayMemberList> (driver->nodePool(), sym(1).UiObjectMember);
} break;

#line 650 "qmljs.g"

case 22: {
    AST::UiArrayMemberList *node = makeAstNode<AST::UiArrayMemberList> (driver->nodePool(),
        sym(1).UiArrayMemberList, sym(3).UiObjectMember);
    node->commaToken = loc(2);
    sym(1).Node = node;
} break;

#line 660 "qmljs.g"

case 23: {
    AST::UiObjectInitializer *node = makeAstNode<AST::UiObjectInitializer> (driver->nodePool(), (AST::UiObjectMemberList*)0);
    node->lbraceToken = loc(1);
    node->rbraceToken = loc(2);
    sym(1).Node = node;
}   break;

#line 670 "qmljs.g"

case 24: {
    AST::UiObjectInitializer *node = makeAstNode<AST::UiObjectInitializer> (driver->nodePool(), sym(2).UiObjectMemberList->finish());
    node->lbraceToken = loc(1);
    node->rbraceToken = loc(3);
    sym(1).Node = node;
}   break;

#line 680 "qmljs.g"

case 25: {
    AST::UiObjectDefinition *node = makeAstNode<AST::UiObjectDefinition> (driver->nodePool(), sym(1).UiQualifiedId->finish(),
        sym(2).UiObjectInitializer);
    sym(1).Node = node;
}   break;

#line 691 "qmljs.g"

case 27: {
    AST::UiArrayBinding *node = makeAstNode<AST::UiArrayBinding> (driver->nodePool(), sym(1).UiQualifiedId->finish(),
        sym(4).UiArrayMemberList->finish());
    node->colonToken = loc(2);
    node->lbracketToken = loc(3);
    node->rbracketToken = loc(5);
    sym(1).Node = node;
}   break;

#line 703 "qmljs.g"

case 28: {
  AST::StringLiteral *node = makeAstNode<AST::StringLiteral> (driver->nodePool(), sym(1).sval);
  node->literalToken = loc(1);
  sym(1).Node = node;
} break;

#line 713 "qmljs.g"

case 30: {
  AST::ExpressionStatement *node = makeAstNode<AST::ExpressionStatement> (driver->nodePool(), sym(1).Expression);
  node->semicolonToken = loc(2);
  sym(1).Node = node;
} break;

#line 723 "qmljs.g"

case 31: {
  if (AST::UiQualifiedId *qualifiedId = reparseAsQualifiedId(sym(3).Expression)) {
    AST::UiObjectBinding *node = makeAstNode<AST::UiObjectBinding> (driver->nodePool(),
      sym(1).UiQualifiedId->finish(), qualifiedId, sym(4).UiObjectInitializer);
    node->colonToken = loc(2);
    sym(1).Node = node;
  } else {
    sym(1).Node = 0;

    diagnostic_messages.append(DiagnosticMessage(DiagnosticMessage::Error, loc(2),
      QLatin1String("Expected a type name after token `:'")));

    return false; // ### recover
  }
} break;

#line 742 "qmljs.g"
case 32:
#line 745 "qmljs.g"
case 33:
#line 748 "qmljs.g"
case 34:
#line 751 "qmljs.g"
case 35:
#line 754 "qmljs.g"
case 36:
#line 757 "qmljs.g"
case 37:
#line 759 "qmljs.g"

{
    AST::UiScriptBinding *node = makeAstNode<AST::UiScriptBinding> (driver->nodePool(), sym(1).UiQualifiedId->finish(),
        sym(3).Statement);
    node->colonToken = loc(2);
    sym(1).Node = node;
}   break;

#line 769 "qmljs.g"

case 38:

#line 773 "qmljs.g"

case 39: {
    sym(1).sval = driver->intern(lexer->characterBuffer(), lexer->characterCount());
    break;
}

#line 783 "qmljs.g"

case 41: {
  sym(1).Node = 0;
} break;

#line 790 "qmljs.g"

case 42: {
  sym(1).Node = sym(1).UiParameterList->finish ();
} break;

#line 797 "qmljs.g"

case 43: {
  AST::UiParameterList *node = makeAstNode<AST::UiParameterList> (driver->nodePool(), sym(1).sval, sym(2).sval);
  node->identifierToken = loc(2);
  sym(1).Node = node;
} break;

#line 806 "qmljs.g"

case 44: {
  AST::UiParameterList *node = makeAstNode<AST::UiParameterList> (driver->nodePool(), sym(1).UiParameterList, sym(3).sval, sym(4).sval);
  node->commaToken = loc(2);
  node->identifierToken = loc(4);
  sym(1).Node = node;
} break;

#line 816 "qmljs.g"

case 45: {
    AST::UiPublicMember *node = makeAstNode<AST::UiPublicMember> (driver->nodePool(), (NameId *)0, sym(2).sval);
    node->type = AST::UiPublicMember::Signal;
    node->propertyToken = loc(1);
    node->typeToken = loc(2);
    node->identifierToken = loc(3);
    node->parameters = sym(4).UiParameterList;
    sym(1).Node = node;
}   break;

#line 829 "qmljs.g"

case 46: {
    AST::UiPublicMember *node = makeAstNode<AST::UiPublicMember> (driver->nodePool(), (NameId *)0, sym(2).sval);
    node->type = AST::UiPublicMember::Signal;
    node->propertyToken = loc(1);
    node->typeToken = loc(2);
    node->identifierToken = loc(3);
    sym(1).Node = node;
}   break;

#line 842 "qmljs.g"

case 48: {
    AST::UiPublicMember *node = makeAstNode<AST::UiPublicMember> (driver->nodePool(), sym(2).sval, sym(3).sval);
    node->propertyToken = loc(1);
    node->typeToken = loc(2);
    node->identifierToken = loc(3);
    node->semicolonToken = loc(4);
    sym(1).Node = node;
}   break;

#line 855 "qmljs.g"

case 50: {
    AST::UiPublicMember *node = makeAstNode<AST::UiPublicMember> (driver->nodePool(), sym(3).sval, sym(4).sval);
    node->isDefaultMember = true;
    node->defaultToken = loc(1);
    node->propertyToken = loc(2);
    node->typeToken = loc(3);
    node->identifierToken = loc(4);
    node->semicolonToken = loc(5);
    sym(1).Node = node;
}   break;

#line 870 "qmljs.g"

case 52: {
    AST::UiPublicMember *node = makeAstNode<AST::UiPublicMember> (driver->nodePool(), sym(2).sval, sym(3).sval,
        sym(5).Expression);
    node->propertyToken = loc(1);
    node->typeToken = loc(2);
    node->identifierToken = loc(3);
    node->colonToken = loc(4);
    node->semicolonToken = loc(6);
    sym(1).Node = node;
}   break;

#line 885 "qmljs.g"

case 54: {
    AST::UiPublicMember *node = makeAstNode<AST::UiPublicMember> (driver->nodePool(), sym(3).sval, sym(4).sval,
        sym(6).Expression);
    node->isDefaultMember = true;
    node->defaultToken = loc(1);
    node->propertyToken = loc(2);
    node->typeToken = loc(3);
    node->identifierToken = loc(4);
    node->colonToken = loc(5);
    node->semicolonToken = loc(7);
    sym(1).Node = node;
}   break;

#line 901 "qmljs.g"

case 55: {
    sym(1).Node = makeAstNode<AST::UiSourceElement>(driver->nodePool(), sym(1).Node);
}   break;

#line 908 "qmljs.g"

case 56: {
    sym(1).Node = makeAstNode<AST::UiSourceElement>(driver->nodePool(), sym(1).Node);
}   break;

#line 915 "qmljs.g"
case 57: 
#line 918 "qmljs.g"

case 58:
{
    AST::UiQualifiedId *node = makeAstNode<AST::UiQualifiedId> (driver->nodePool(), driver->intern(lexer->characterBuffer(), lexer->characterCount()));
    node->identifierToken = loc(1);
    sym(1).Node = node;
}   break;

#line 930 "qmljs.g"

case 60: {
    QString s = QLatin1String(QmlJSGrammar::spell[T_PROPERTY]);
    sym(1).sval = driver->intern(s.constData(), s.length());
    break;
}

#line 939 "qmljs.g"

case 61: {
    QString s = QLatin1String(QmlJSGrammar::spell[T_SIGNAL]);
    sym(1).sval = driver->intern(s.constData(), s.length());
    break;
}

#line 952 "qmljs.g"

case 62: {
  AST::ThisExpression *node = makeAstNode<AST::ThisExpression> (driver->nodePool());
  node->thisToken = loc(1);
  sym(1).Node = node;
} break;

#line 961 "qmljs.g"

case 63: {
  AST::IdentifierExpression *node = makeAstNode<AST::IdentifierExpression> (driver->nodePool(), sym(1).sval);
  node->identifierToken = loc(1);
  sym(1).Node = node;
} break;

#line 970 "qmljs.g"

case 64: {
  AST::NullExpression *node = makeAstNode<AST::NullExpression> (driver->nodePool());
  node->nullToken = loc(1);
  sym(1).Node = node;
} break;

#line 979 "qmljs.g"

case 65: {
  AST::TrueLiteral *node = makeAstNode<AST::TrueLiteral> (driver->nodePool());
  node->trueToken = loc(1);
  sym(1).Node = node;
} break;

#line 988 "qmljs.g"

case 66: {
  AST::FalseLiteral *node = makeAstNode<AST::FalseLiteral> (driver->nodePool());
  node->falseToken = loc(1);
  sym(1).Node = node;
} break;

#line 997 "qmljs.g"

case 67: {
  AST::NumericLiteral *node = makeAstNode<AST::NumericLiteral> (driver->nodePool(), sym(1).dval, lexer->flags);
  node->literalToken = loc(1);
  sym(1).Node = node;
} break;

#line 1006 "qmljs.g"

case 68: {
  AST::StringLiteral *node = makeAstNode<AST::StringLiteral> (driver->nodePool(), sym(1).sval);
  node->literalToken = loc(1);
  sym(1).Node = node;
} break;

#line 1018 "qmljs.g"

case 69: {
  bool rx = lexer->scanRegExp(Lexer::NoPrefix);
  if (!rx) {
    diagnostic_messages.append(DiagnosticMessage(DiagnosticMessage::Error, location(lexer), lexer->errorMessage()));
    return false; // ### remove me
  }
  AST::RegExpLiteral *node = makeAstNode<AST::RegExpLiteral> (driver->nodePool(), lexer->pattern, lexer->flags);
  node->literalToken = loc(1);
  sym(1).Node = node;
} break;

#line 1035 "qmljs.g"

case 70: {
  bool rx = lexer->scanRegExp(Lexer::EqualPrefix);
  if (!rx) {
    diagnostic_messages.append(DiagnosticMessage(DiagnosticMessage::Error, location(lexer), lexer->errorMessage()));
    return false;
  }
  AST::RegExpLiteral *node = makeAstNode<AST::RegExpLiteral> (driver->nodePool(), lexer->pattern, lexer->flags);
  node->literalToken = loc(1);
  sym(1).Node = node;
} break;

#line 1049 "qmljs.g"

case 71: {
  AST::ArrayLiteral *node = makeAstNode<AST::ArrayLiteral> (driver->nodePool(), (AST::Elision *) 0);
  node->lbracketToken = loc(1);
  node->rbracketToken = loc(2);
  sym(1).Node = node;
} break;

#line 1059 "qmljs.g"

case 72: {
  AST::ArrayLiteral *node = makeAstNode<AST::ArrayLiteral> (driver->nodePool(), sym(2).Elision->finish());
  node->lbracketToken = loc(1);
  node->rbracketToken = loc(3);
  sym(1).Node = node;
} break;

#line 1069 "qmljs.g"

case 73: {
  AST::ArrayLiteral *node = makeAstNode<AST::ArrayLiteral> (driver->nodePool(), sym(2).ElementList->finish ());
  node->lbracketToken = loc(1);
  node->rbracketToken = loc(3);
  sym(1).Node = node;
} break;

#line 1079 "qmljs.g"

case 74: {
  AST::ArrayLiteral *node = makeAstNode<AST::ArrayLiteral> (driver->nodePool(), sym(2).ElementList->finish (),
    (AST::Elision *) 0);
  node->lbracketToken = loc(1);
  node->commaToken = loc(3);
  node->rbracketToken = loc(4);
  sym(1).Node = node;
} break;

#line 1091 "qmljs.g"

case 75: {
  AST::ArrayLiteral *node = makeAstNode<AST::ArrayLiteral> (driver->nodePool(), sym(2).ElementList->finish (),
    sym(4).Elision->finish());
  node->lbracketToken = loc(1);
  node->commaToken = loc(3);
  node->rbracketToken = loc(5);
  sym(1).Node = node;
} break;

#line 1110 "qmljs.g"

case 76: {
  AST::ObjectLiteral *node = 0;
  if (sym(2).Node)
    node = makeAstNode<AST::ObjectLiteral> (driver->nodePool(),
        sym(2).PropertyNameAndValueList->finish ());
  else
    node = makeAstNode<AST::ObjectLiteral> (driver->nodePool());
  node->lbraceToken = loc(1);
  node->lbraceToken = loc(3);
  sym(1).Node = node;
} break;

#line 1125 "qmljs.g"

case 77: {
  AST::ObjectLiteral *node = makeAstNode<AST::ObjectLiteral> (driver->nodePool(),
    sym(2).PropertyNameAndValueList->finish ());
  node->lbraceToken = loc(1);
  node->lbraceToken = loc(4);
  sym(1).Node = node;
} break;

#line 1136 "qmljs.g"

case 78: {
  AST::NestedExpression *node = makeAstNode<AST::NestedExpression>(driver->nodePool(), sym(2).Expression);
  node->lparenToken = loc(1);
  node->rparenToken = loc(3);
  sym(1).Node = node;
} break;

#line 1146 "qmljs.g"

case 79: {
    AST::UiQualifiedId *node = makeAstNode<AST::UiQualifiedId> (driver->nodePool(), sym(1).sval);
    node->identifierToken = loc(1);
    sym(1).Node = node;
}   break;

#line 1155 "qmljs.g"

case 80: {
    AST::UiQualifiedId *node = makeAstNode<AST::UiQualifiedId> (driver->nodePool(), sym(1).UiQualifiedId, sym(3).sval);
    node->identifierToken = loc(3);
    sym(1).Node = node;
}   break;

#line 1164 "qmljs.g"

case 81: {
  sym(1).Node = makeAstNode<AST::ElementList> (driver->nodePool(), (AST::Elision *) 0, sym(1).Expression);
} break;

#line 1171 "qmljs.g"

case 82: {
  sym(1).Node = makeAstNode<AST::ElementList> (driver->nodePool(), sym(1).Elision->finish(), sym(2).Expression);
} break;

#line 1178 "qmljs.g"

case 83: {
  AST::ElementList *node = makeAstNode<AST::ElementList> (driver->nodePool(), sym(1).ElementList,
    (AST::Elision *) 0, sym(3).Expression);
  node->commaToken = loc(2);
  sym(1).Node = node;
} break;

#line 1188 "qmljs.g"

case 84: {
  AST::ElementList *node = makeAstNode<AST::ElementList> (driver->nodePool(), sym(1).ElementList, sym(3).Elision->finish(),
    sym(4).Expression);
  node->commaToken = loc(2);
  sym(1).Node = node;
} break;

#line 1198 "qmljs.g"

case 85: {
  AST::Elision *node = makeAstNode<AST::Elision> (driver->nodePool());
  node->commaToken = loc(1);
  sym(1).Node = node;
} break;

#line 1207 "qmljs.g"

case 86: {
  AST::Elision *node = makeAstNode<AST::Elision> (driver->nodePool(), sym(1).Elision);
  node->commaToken = loc(2);
  sym(1).Node = node;
} break;

#line 1216 "qmljs.g"

case 87: {
  AST::PropertyNameAndValueList *node = makeAstNode<AST::PropertyNameAndValueList> (driver->nodePool(),
      sym(1).PropertyName, sym(3).Expression);
  node->colonToken = loc(2);
  sym(1).Node = node;
} break;

#line 1226 "qmljs.g"

case 88: {
  AST::PropertyNameAndValueList *node = makeAstNode<AST::PropertyNameAndValueList> (driver->nodePool(),
      sym(1).PropertyNameAndValueList, sym(3).PropertyName, sym(5).Expression);
  node->commaToken = loc(2);
  node->colonToken = loc(4);
  sym(1).Node = node;
} break;

#line 1237 "qmljs.g"

case 89: {
  AST::IdentifierPropertyName *node = makeAstNode<AST::IdentifierPropertyName> (driver->nodePool(), sym(1).sval);
  node->propertyNameToken = loc(1);
  sym(1).Node = node;
} break;

#line 1246 "qmljs.g"
case 90:
#line 1249 "qmljs.g"

case 91: {
  AST::IdentifierPropertyName *node = makeAstNode<AST::IdentifierPropertyName> (driver->nodePool(), driver->intern(lexer->characterBuffer(), lexer->characterCount()));
  node->propertyNameToken = loc(1);
  sym(1).Node = node;
} break;

#line 1258 "qmljs.g"

case 92: {
  AST::StringLiteralPropertyName *node = makeAstNode<AST::StringLiteralPropertyName> (driver->nodePool(), sym(1).sval);
  node->propertyNameToken = loc(1);
  sym(1).Node = node;
} break;

#line 1267 "qmljs.g"

case 93: {
  AST::NumericLiteralPropertyName *node = makeAstNode<AST::NumericLiteralPropertyName> (driver->nodePool(), sym(1).dval);
  node->propertyNameToken = loc(1);
  sym(1).Node = node;
} break;

#line 1276 "qmljs.g"

case 94: {
  AST::IdentifierPropertyName *node = makeAstNode<AST::IdentifierPropertyName> (driver->nodePool(), sym(1).sval);
  node->propertyNameToken = loc(1);
  sym(1).Node = node;
} break;

#line 1285 "qmljs.g"

case 95:

#line 1289 "qmljs.g"

case 96:

#line 1293 "qmljs.g"

case 97:

#line 1297 "qmljs.g"

case 98:

#line 1301 "qmljs.g"

case 99:

#line 1305 "qmljs.g"

case 100:

#line 1309 "qmljs.g"

case 101:

#line 1313 "qmljs.g"

case 102:

#line 1317 "qmljs.g"

case 103:

#line 1321 "qmljs.g"

case 104:

#line 1325 "qmljs.g"

case 105:

#line 1329 "qmljs.g"

case 106:

#line 1333 "qmljs.g"

case 107:

#line 1337 "qmljs.g"

case 108:

#line 1341 "qmljs.g"

case 109:

#line 1345 "qmljs.g"

case 110:

#line 1349 "qmljs.g"

case 111:

#line 1353 "qmljs.g"

case 112:

#line 1357 "qmljs.g"

case 113:

#line 1361 "qmljs.g"

case 114:

#line 1365 "qmljs.g"

case 115:

#line 1369 "qmljs.g"

case 116:

#line 1373 "qmljs.g"

case 117:

#line 1377 "qmljs.g"

case 118:

#line 1381 "qmljs.g"

case 119:

#line 1385 "qmljs.g"

case 120:

#line 1389 "qmljs.g"

case 121:

#line 1393 "qmljs.g"

case 122:

#line 1397 "qmljs.g"

case 123:

#line 1401 "qmljs.g"

case 124:

#line 1405 "qmljs.g"

case 125:
{
  sym(1).sval = driver->intern(lexer->characterBuffer(), lexer->characterCount());
} break;

#line 1419 "qmljs.g"

case 130: {
  AST::ArrayMemberExpression *node = makeAstNode<AST::ArrayMemberExpression> (driver->nodePool(), sym(1).Expression, sym(3).Expression);
  node->lbracketToken = loc(2);
  node->rbracketToken = loc(4);
  sym(1).Node = node;
} break;

#line 1429 "qmljs.g"

case 131: {
  AST::FieldMemberExpression *node = makeAstNode<AST::FieldMemberExpression> (driver->nodePool(), sym(1).Expression, sym(3).sval);
  node->dotToken = loc(2);
  node->identifierToken = loc(3);
  sym(1).Node = node;
} break;

#line 1439 "qmljs.g"

case 132: {
  AST::NewMemberExpression *node = makeAstNode<AST::NewMemberExpression> (driver->nodePool(), sym(2).Expression, sym(4).ArgumentList);
  node->newToken = loc(1);
  node->lparenToken = loc(3);
  node->rparenToken = loc(5);
  sym(1).Node = node;
} break;

#line 1452 "qmljs.g"

case 134: {
  AST::NewExpression *node = makeAstNode<AST::NewExpression> (driver->nodePool(), sym(2).Expression);
  node->newToken = loc(1);
  sym(1).Node = node;
} break;

#line 1461 "qmljs.g"

case 135: {
  AST::CallExpression *node = makeAstNode<AST::CallExpression> (driver->nodePool(), sym(1).Expression, sym(3).ArgumentList);
  node->lparenToken = loc(2);
  node->rparenToken = loc(4);
  sym(1).Node = node;
} break;

#line 1471 "qmljs.g"

case 136: {
  AST::CallExpression *node = makeAstNode<AST::CallExpression> (driver->nodePool(), sym(1).Expression, sym(3).ArgumentList);
  node->lparenToken = loc(2);
  node->rparenToken = loc(4);
  sym(1).Node = node;
} break;

#line 1481 "qmljs.g"

case 137: {
  AST::ArrayMemberExpression *node = makeAstNode<AST::ArrayMemberExpression> (driver->nodePool(), sym(1).Expression, sym(3).Expression);
  node->lbracketToken = loc(2);
  node->rbracketToken = loc(4);
  sym(1).Node = node;
} break;

#line 1491 "qmljs.g"

case 138: {
  AST::FieldMemberExpression *node = makeAstNode<AST::FieldMemberExpression> (driver->nodePool(), sym(1).Expression, sym(3).sval);
  node->dotToken = loc(2);
  node->identifierToken = loc(3);
  sym(1).Node = node;
} break;

#line 1501 "qmljs.g"

case 139: {
  sym(1).Node = 0;
} break;

#line 1508 "qmljs.g"

case 140: {
  sym(1).Node = sym(1).ArgumentList->finish();
} break;

#line 1515 "qmljs.g"

case 141: {
  sym(1).Node = makeAstNode<AST::ArgumentList> (driver->nodePool(), sym(1).Expression);
} break;

#line 1522 "qmljs.g"

case 142: {
  AST::ArgumentList *node = makeAstNode<AST::ArgumentList> (driver->nodePool(), sym(1).ArgumentList, sym(3).Expression);
  node->commaToken = loc(2);
  sym(1).Node = node;
} break;

#line 1535 "qmljs.g"

case 146: {
  AST::PostIncrementExpression *node = makeAstNode<AST::PostIncrementExpression> (driver->nodePool(), sym(1).Expression);
  node->incrementToken = loc(2);
  sym(1).Node = node;
} break;

#line 1544 "qmljs.g"

case 147: {
  AST::PostDecrementExpression *node = makeAstNode<AST::PostDecrementExpression> (driver->nodePool(), sym(1).Expression);
  node->decrementToken = loc(2);
  sym(1).Node = node;
} break;

#line 1555 "qmljs.g"

case 149: {
  AST::DeleteExpression *node = makeAstNode<AST::DeleteExpression> (driver->nodePool(), sym(2).Expression);
  node->deleteToken = loc(1);
  sym(1).Node = node;
} break;

#line 1564 "qmljs.g"

case 150: {
  AST::VoidExpression *node = makeAstNode<AST::VoidExpression> (driver->nodePool(), sym(2).Expression);
  node->voidToken = loc(1);
  sym(1).Node = node;
} break;

#line 1573 "qmljs.g"

case 151: {
  AST::TypeOfExpression *node = makeAstNode<AST::TypeOfExpression> (driver->nodePool(), sym(2).Expression);
  node->typeofToken = loc(1);
  sym(1).Node = node;
} break;

#line 1582 "qmljs.g"

case 152: {
  AST::PreIncrementExpression *node = makeAstNode<AST::PreIncrementExpression> (driver->nodePool(), sym(2).Expression);
  node->incrementToken = loc(1);
  sym(1).Node = node;
} break;

#line 1591 "qmljs.g"

case 153: {
  AST::PreDecrementExpression *node = makeAstNode<AST::PreDecrementExpression> (driver->nodePool(), sym(2).Expression);
  node->decrementToken = loc(1);
  sym(1).Node = node;
} break;

#line 1600 "qmljs.g"

case 154: {
  AST::UnaryPlusExpression *node = makeAstNode<AST::UnaryPlusExpression> (driver->nodePool(), sym(2).Expression);
  node->plusToken = loc(1);
  sym(1).Node = node;
} break;

#line 1609 "qmljs.g"

case 155: {
  AST::UnaryMinusExpression *node = makeAstNode<AST::UnaryMinusExpression> (driver->nodePool(), sym(2).Expression);
  node->minusToken = loc(1);
  sym(1).Node = node;
} break;

#line 1618 "qmljs.g"

case 156: {
  AST::TildeExpression *node = makeAstNode<AST::TildeExpression> (driver->nodePool(), sym(2).Expression);
  node->tildeToken = loc(1);
  sym(1).Node = node;
} break;

#line 1627 "qmljs.g"

case 157: {
  AST::NotExpression *node = makeAstNode<AST::NotExpression> (driver->nodePool(), sym(2).Expression);
  node->notToken = loc(1);
  sym(1).Node = node;
} break;

#line 1638 "qmljs.g"

case 159: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::Mul, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 1648 "qmljs.g"

case 160: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::Div, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 1658 "qmljs.g"

case 161: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::Mod, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 1670 "qmljs.g"

case 163: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::Add, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 1680 "qmljs.g"

case 164: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::Sub, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 1692 "qmljs.g"

case 166: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::LShift, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 1702 "qmljs.g"

case 167: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::RShift, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 1712 "qmljs.g"

case 168: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::URShift, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 1724 "qmljs.g"

case 170: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::Lt, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 1734 "qmljs.g"

case 171: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::Gt, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 1744 "qmljs.g"

case 172: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::Le, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 1754 "qmljs.g"

case 173: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::Ge, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 1764 "qmljs.g"

case 174: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::InstanceOf, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 1774 "qmljs.g"

case 175: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::In, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 1786 "qmljs.g"

case 177: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::Lt, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 1796 "qmljs.g"

case 178: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::Gt, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 1806 "qmljs.g"

case 179: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::Le, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 1816 "qmljs.g"

case 180: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
   QSOperator::Ge, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 1826 "qmljs.g"

case 181: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::InstanceOf, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 1838 "qmljs.g"

case 183: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::Equal, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 1848 "qmljs.g"

case 184: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::NotEqual, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 1858 "qmljs.g"

case 185: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::StrictEqual, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 1868 "qmljs.g"

case 186: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::StrictNotEqual, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 1880 "qmljs.g"

case 188: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::Equal, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 1890 "qmljs.g"

case 189: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::NotEqual, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 1900 "qmljs.g"

case 190: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::StrictEqual, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 1910 "qmljs.g"

case 191: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::StrictNotEqual, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 1922 "qmljs.g"

case 193: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::BitAnd, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 1934 "qmljs.g"

case 195: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::BitAnd, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 1946 "qmljs.g"

case 197: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::BitXor, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 1958 "qmljs.g"

case 199: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::BitXor, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 1970 "qmljs.g"

case 201: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::BitOr, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 1982 "qmljs.g"

case 203: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::BitOr, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 1994 "qmljs.g"

case 205: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::And, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 2006 "qmljs.g"

case 207: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::And, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 2018 "qmljs.g"

case 209: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::Or, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 2030 "qmljs.g"

case 211: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    QSOperator::Or, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 2042 "qmljs.g"

case 213: {
  AST::ConditionalExpression *node = makeAstNode<AST::ConditionalExpression> (driver->nodePool(), sym(1).Expression,
    sym(3).Expression, sym(5).Expression);
  node->questionToken = loc(2);
  node->colonToken = loc(4);
  sym(1).Node = node;
} break;

#line 2055 "qmljs.g"

case 215: {
  AST::ConditionalExpression *node = makeAstNode<AST::ConditionalExpression> (driver->nodePool(), sym(1).Expression,
    sym(3).Expression, sym(5).Expression);
  node->questionToken = loc(2);
  node->colonToken = loc(4);
  sym(1).Node = node;
} break;

#line 2068 "qmljs.g"

case 217: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    sym(2).ival, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 2080 "qmljs.g"

case 219: {
  AST::BinaryExpression *node = makeAstNode<AST::BinaryExpression> (driver->nodePool(), sym(1).Expression,
    sym(2).ival, sym(3).Expression);
  node->operatorToken = loc(2);
  sym(1).Node = node;
} break;

#line 2090 "qmljs.g"

case 220: {
  sym(1).ival = QSOperator::Assign;
} break;

#line 2097 "qmljs.g"

case 221: {
  sym(1).ival = QSOperator::InplaceMul;
} break;

#line 2104 "qmljs.g"

case 222: {
  sym(1).ival = QSOperator::InplaceDiv;
} break;

#line 2111 "qmljs.g"

case 223: {
  sym(1).ival = QSOperator::InplaceMod;
} break;

#line 2118 "qmljs.g"

case 224: {
  sym(1).ival = QSOperator::InplaceAdd;
} break;

#line 2125 "qmljs.g"

case 225: {
  sym(1).ival = QSOperator::InplaceSub;
} break;

#line 2132 "qmljs.g"

case 226: {
  sym(1).ival = QSOperator::InplaceLeftShift;
} break;

#line 2139 "qmljs.g"

case 227: {
  sym(1).ival = QSOperator::InplaceRightShift;
} break;

#line 2146 "qmljs.g"

case 228: {
  sym(1).ival = QSOperator::InplaceURightShift;
} break;

#line 2153 "qmljs.g"

case 229: {
  sym(1).ival = QSOperator::InplaceAnd;
} break;

#line 2160 "qmljs.g"

case 230: {
  sym(1).ival = QSOperator::InplaceXor;
} break;

#line 2167 "qmljs.g"

case 231: {
  sym(1).ival = QSOperator::InplaceOr;
} break;

#line 2176 "qmljs.g"

case 233: {
  AST::Expression *node = makeAstNode<AST::Expression> (driver->nodePool(), sym(1).Expression, sym(3).Expression);
  node->commaToken = loc(2);
  sym(1).Node = node;
} break;

#line 2185 "qmljs.g"

case 234: {
  sym(1).Node = 0;
} break;

#line 2196 "qmljs.g"

case 237: {
  AST::Expression *node = makeAstNode<AST::Expression> (driver->nodePool(), sym(1).Expression, sym(3).Expression);
  node->commaToken = loc(2);
  sym(1).Node = node;
} break;

#line 2205 "qmljs.g"

case 238: {
  sym(1).Node = 0;
} break;

#line 2231 "qmljs.g"

case 255: {
  AST::Block *node = makeAstNode<AST::Block> (driver->nodePool(), sym(2).StatementList);
  node->lbraceToken = loc(1);
  node->rbraceToken = loc(3);
  sym(1).Node = node;
} break;

#line 2241 "qmljs.g"

case 256: {
  sym(1).Node = makeAstNode<AST::StatementList> (driver->nodePool(), sym(1).Statement);
} break;

#line 2248 "qmljs.g"

case 257: {
  sym(1).Node = makeAstNode<AST::StatementList> (driver->nodePool(), sym(1).StatementList, sym(2).Statement);
} break;

#line 2255 "qmljs.g"

case 258: {
  sym(1).Node = 0;
} break;

#line 2262 "qmljs.g"

case 259: {
  sym(1).Node = sym(1).StatementList->finish ();
} break;

#line 2270 "qmljs.g"

case 261: {
  AST::VariableStatement *node = makeAstNode<AST::VariableStatement> (driver->nodePool(),
     sym(2).VariableDeclarationList->finish (/*readOnly=*/sym(1).ival == T_CONST));
  node->declarationKindToken = loc(1);
  node->semicolonToken = loc(3);
  sym(1).Node = node;
} break;

#line 2281 "qmljs.g"

case 262: {
  sym(1).ival = T_CONST;
} break;

#line 2288 "qmljs.g"

case 263: {
  sym(1).ival = T_VAR;
} break;

#line 2295 "qmljs.g"

case 264: {
  sym(1).Node = makeAstNode<AST::VariableDeclarationList> (driver->nodePool(), sym(1).VariableDeclaration);
} break;

#line 2302 "qmljs.g"

case 265: {
  AST::VariableDeclarationList *node = makeAstNode<AST::VariableDeclarationList> (driver->nodePool(),
    sym(1).VariableDeclarationList, sym(3).VariableDeclaration);
  node->commaToken = loc(2);
  sym(1).Node = node;
} break;

#line 2312 "qmljs.g"

case 266: {
  sym(1).Node = makeAstNode<AST::VariableDeclarationList> (driver->nodePool(), sym(1).VariableDeclaration);
} break;

#line 2319 "qmljs.g"

case 267: {
  sym(1).Node = makeAstNode<AST::VariableDeclarationList> (driver->nodePool(), sym(1).VariableDeclarationList, sym(3).VariableDeclaration);
} break;

#line 2326 "qmljs.g"

case 268: {
  AST::VariableDeclaration *node = makeAstNode<AST::VariableDeclaration> (driver->nodePool(), sym(1).sval, sym(2).Expression);
  node->identifierToken = loc(1);
  sym(1).Node = node;
} break;

#line 2335 "qmljs.g"

case 269: {
  AST::VariableDeclaration *node = makeAstNode<AST::VariableDeclaration> (driver->nodePool(), sym(1).sval, sym(2).Expression);
  node->identifierToken = loc(1);
  sym(1).Node = node;
} break;

#line 2344 "qmljs.g"

case 270: {
  // ### TODO: AST for initializer
  sym(1) = sym(2);
} break;

#line 2352 "qmljs.g"

case 271: {
  sym(1).Node = 0;
} break;

#line 2361 "qmljs.g"

case 273: {
  // ### TODO: AST for initializer
  sym(1) = sym(2);
} break;

#line 2369 "qmljs.g"

case 274: {
  sym(1).Node = 0;
} break;

#line 2378 "qmljs.g"

case 276: {
  AST::EmptyStatement *node = makeAstNode<AST::EmptyStatement> (driver->nodePool());
  node->semicolonToken = loc(1);
  sym(1).Node = node;
} break;

#line 2388 "qmljs.g"

case 278: {
  AST::ExpressionStatement *node = makeAstNode<AST::ExpressionStatement> (driver->nodePool(), sym(1).Expression);
  node->semicolonToken = loc(2);
  sym(1).Node = node;
} break;

#line 2397 "qmljs.g"

case 279: {
  AST::IfStatement *node = makeAstNode<AST::IfStatement> (driver->nodePool(), sym(3).Expression, sym(5).Statement, sym(7).Statement);
  node->ifToken = loc(1);
  node->lparenToken = loc(2);
  node->rparenToken = loc(4);
  node->elseToken = loc(5);
  sym(1).Node = node;
} break;

#line 2409 "qmljs.g"

case 280: {
  AST::IfStatement *node = makeAstNode<AST::IfStatement> (driver->nodePool(), sym(3).Expression, sym(5).Statement);
  node->ifToken = loc(1);
  node->lparenToken = loc(2);
  node->rparenToken = loc(4);
  sym(1).Node = node;
} break;

#line 2422 "qmljs.g"

case 282: {
  AST::DoWhileStatement *node = makeAstNode<AST::DoWhileStatement> (driver->nodePool(), sym(2).Statement, sym(5).Expression);
  node->doToken = loc(1);
  node->whileToken = loc(3);
  node->lparenToken = loc(4);
  node->rparenToken = loc(6);
  node->semicolonToken = loc(7);
  sym(1).Node = node;
} break;

#line 2435 "qmljs.g"

case 283: {
  AST::WhileStatement *node = makeAstNode<AST::WhileStatement> (driver->nodePool(), sym(3).Expression, sym(5).Statement);
  node->whileToken = loc(1);
  node->lparenToken = loc(2);
  node->rparenToken = loc(4);
  sym(1).Node = node;
} break;

#line 2446 "qmljs.g"

case 284: {
  AST::ForStatement *node = makeAstNode<AST::ForStatement> (driver->nodePool(), sym(3).Expression,
    sym(5).Expression, sym(7).Expression, sym(9).Statement);
  node->forToken = loc(1);
  node->lparenToken = loc(2);
  node->firstSemicolonToken = loc(4);
  node->secondSemicolonToken = loc(6);
  node->rparenToken = loc(8);
  sym(1).Node = node;
} break;

#line 2460 "qmljs.g"

case 285: {
  AST::LocalForStatement *node = makeAstNode<AST::LocalForStatement> (driver->nodePool(),
     sym(4).VariableDeclarationList->finish (/*readOnly=*/false), sym(6).Expression,
     sym(8).Expression, sym(10).Statement);
  node->forToken = loc(1);
  node->lparenToken = loc(2);
  node->varToken = loc(3);
  node->firstSemicolonToken = loc(5);
  node->secondSemicolonToken = loc(7);
  node->rparenToken = loc(9);
  sym(1).Node = node;
} break;

#line 2476 "qmljs.g"

case 286: {
  AST:: ForEachStatement *node = makeAstNode<AST::ForEachStatement> (driver->nodePool(), sym(3).Expression,
    sym(5).Expression, sym(7).Statement);
  node->forToken = loc(1);
  node->lparenToken = loc(2);
  node->inToken = loc(4);
  node->rparenToken = loc(6);
  sym(1).Node = node;
} break;

#line 2489 "qmljs.g"

case 287: {
  AST::LocalForEachStatement *node = makeAstNode<AST::LocalForEachStatement> (driver->nodePool(),
    sym(4).VariableDeclaration, sym(6).Expression, sym(8).Statement);
  node->forToken = loc(1);
  node->lparenToken = loc(2);
  node->varToken = loc(3);
  node->inToken = loc(5);
  node->rparenToken = loc(7);
  sym(1).Node = node;
} break;

#line 2504 "qmljs.g"

case 289: {
  AST::ContinueStatement *node = makeAstNode<AST::ContinueStatement> (driver->nodePool());
  node->continueToken = loc(1);
  node->semicolonToken = loc(2);
  sym(1).Node = node;
} break;

#line 2515 "qmljs.g"

case 291: {
  AST::ContinueStatement *node = makeAstNode<AST::ContinueStatement> (driver->nodePool(), sym(2).sval);
  node->continueToken = loc(1);
  node->identifierToken = loc(2);
  node->semicolonToken = loc(3);
  sym(1).Node = node;
} break;

#line 2527 "qmljs.g"

case 293: {
  AST::BreakStatement *node = makeAstNode<AST::BreakStatement> (driver->nodePool());
  node->breakToken = loc(1);
  node->semicolonToken = loc(2);
  sym(1).Node = node;
} break;

#line 2538 "qmljs.g"

case 295: {
  AST::BreakStatement *node = makeAstNode<AST::BreakStatement> (driver->nodePool(), sym(2).sval);
  node->breakToken = loc(1);
  node->identifierToken = loc(2);
  node->semicolonToken = loc(3);
  sym(1).Node = node;
} break;

#line 2550 "qmljs.g"

case 297: {
  AST::ReturnStatement *node = makeAstNode<AST::ReturnStatement> (driver->nodePool(), sym(2).Expression);
  node->returnToken = loc(1);
  node->semicolonToken = loc(3);
  sym(1).Node = node;
} break;

#line 2560 "qmljs.g"

case 298: {
  AST::WithStatement *node = makeAstNode<AST::WithStatement> (driver->nodePool(), sym(3).Expression, sym(5).Statement);
  node->withToken = loc(1);
  node->lparenToken = loc(2);
  node->rparenToken = loc(4);
  sym(1).Node = node;
} break;

#line 2571 "qmljs.g"

case 299: {
  AST::SwitchStatement *node = makeAstNode<AST::SwitchStatement> (driver->nodePool(), sym(3).Expression, sym(5).CaseBlock);
  node->switchToken = loc(1);
  node->lparenToken = loc(2);
  node->rparenToken = loc(4);
  sym(1).Node = node;
} break;

#line 2582 "qmljs.g"

case 300: {
  AST::CaseBlock *node = makeAstNode<AST::CaseBlock> (driver->nodePool(), sym(2).CaseClauses);
  node->lbraceToken = loc(1);
  node->rbraceToken = loc(3);
  sym(1).Node = node;
} break;

#line 2592 "qmljs.g"

case 301: {
  AST::CaseBlock *node = makeAstNode<AST::CaseBlock> (driver->nodePool(), sym(2).CaseClauses, sym(3).DefaultClause, sym(4).CaseClauses);
  node->lbraceToken = loc(1);
  node->rbraceToken = loc(5);
  sym(1).Node = node;
} break;

#line 2602 "qmljs.g"

case 302: {
  sym(1).Node = makeAstNode<AST::CaseClauses> (driver->nodePool(), sym(1).CaseClause);
} break;

#line 2609 "qmljs.g"

case 303: {
  sym(1).Node = makeAstNode<AST::CaseClauses> (driver->nodePool(), sym(1).CaseClauses, sym(2).CaseClause);
} break;

#line 2616 "qmljs.g"

case 304: {
  sym(1).Node = 0;
} break;

#line 2623 "qmljs.g"

case 305: {
  sym(1).Node = sym(1).CaseClauses->finish ();
} break;

#line 2630 "qmljs.g"

case 306: {
  AST::CaseClause *node = makeAstNode<AST::CaseClause> (driver->nodePool(), sym(2).Expression, sym(4).StatementList);
  node->caseToken = loc(1);
  node->colonToken = loc(3);
  sym(1).Node = node;
} break;

#line 2640 "qmljs.g"

case 307: {
  AST::DefaultClause *node = makeAstNode<AST::DefaultClause> (driver->nodePool(), sym(3).StatementList);
  node->defaultToken = loc(1);
  node->colonToken = loc(2);
  sym(1).Node = node;
} break;

#line 2650 "qmljs.g"
case 308:
#line 2653 "qmljs.g"

case 309: {
  AST::LabelledStatement *node = makeAstNode<AST::LabelledStatement> (driver->nodePool(), driver->intern(lexer->characterBuffer(), lexer->characterCount()), sym(3).Statement);
  node->identifierToken = loc(1);
  node->colonToken = loc(2);
  sym(1).Node = node;
} break;

#line 2663 "qmljs.g"

case 310: {
  AST::LabelledStatement *node = makeAstNode<AST::LabelledStatement> (driver->nodePool(), sym(1).sval, sym(3).Statement);
  node->identifierToken = loc(1);
  node->colonToken = loc(2);
  sym(1).Node = node;
} break;

#line 2674 "qmljs.g"

case 312: {
  AST::ThrowStatement *node = makeAstNode<AST::ThrowStatement> (driver->nodePool(), sym(2).Expression);
  node->throwToken = loc(1);
  node->semicolonToken = loc(3);
  sym(1).Node = node;
} break;

#line 2684 "qmljs.g"

case 313: {
  AST::TryStatement *node = makeAstNode<AST::TryStatement> (driver->nodePool(), sym(2).Statement, sym(3).Catch);
  node->tryToken = loc(1);
  sym(1).Node = node;
} break;

#line 2693 "qmljs.g"

case 314: {
  AST::TryStatement *node = makeAstNode<AST::TryStatement> (driver->nodePool(), sym(2).Statement, sym(3).Finally);
  node->tryToken = loc(1);
  sym(1).Node = node;
} break;

#line 2702 "qmljs.g"

case 315: {
  AST::TryStatement *node = makeAstNode<AST::TryStatement> (driver->nodePool(), sym(2).Statement, sym(3).Catch, sym(4).Finally);
  node->tryToken = loc(1);
  sym(1).Node = node;
} break;

#line 2711 "qmljs.g"

case 316: {
  AST::Catch *node = makeAstNode<AST::Catch> (driver->nodePool(), sym(3).sval, sym(5).Block);
  node->catchToken = loc(1);
  node->lparenToken = loc(2);
  node->identifierToken = loc(3);
  node->rparenToken = loc(4);
  sym(1).Node = node;
} break;

#line 2723 "qmljs.g"

case 317: {
  AST::Finally *node = makeAstNode<AST::Finally> (driver->nodePool(), sym(2).Block);
  node->finallyToken = loc(1);
  sym(1).Node = node;
} break;

#line 2733 "qmljs.g"

case 319: {
  AST::DebuggerStatement *node = makeAstNode<AST::DebuggerStatement> (driver->nodePool());
  node->debuggerToken = loc(1);
  node->semicolonToken = loc(2);
  sym(1).Node = node;
} break;

#line 2743 "qmljs.g"

case 320: {
  AST::FunctionDeclaration *node = makeAstNode<AST::FunctionDeclaration> (driver->nodePool(), sym(2).sval, sym(4).FormalParameterList, sym(7).FunctionBody);
  node->functionToken = loc(1);
  node->identifierToken = loc(2);
  node->lparenToken = loc(3);
  node->rparenToken = loc(5);
  node->lbraceToken = loc(6);
  node->rbraceToken = loc(8);
  sym(1).Node = node;
} break;

#line 2757 "qmljs.g"

case 321: {
  AST::FunctionExpression *node = makeAstNode<AST::FunctionExpression> (driver->nodePool(), sym(2).sval, sym(4).FormalParameterList, sym(7).FunctionBody);
  node->functionToken = loc(1);
  if (sym(2).sval)
      node->identifierToken = loc(2);
  node->lparenToken = loc(3);
  node->rparenToken = loc(5);
  node->lbraceToken = loc(6);
  node->rbraceToken = loc(8);
  sym(1).Node = node;
} break;

#line 2772 "qmljs.g"

case 322: {
  AST::FormalParameterList *node = makeAstNode<AST::FormalParameterList> (driver->nodePool(), sym(1).sval);
  node->identifierToken = loc(1);
  sym(1).Node = node;
} break;

#line 2781 "qmljs.g"

case 323: {
  AST::FormalParameterList *node = makeAstNode<AST::FormalParameterList> (driver->nodePool(), sym(1).FormalParameterList, sym(3).sval);
  node->commaToken = loc(2);
  node->identifierToken = loc(3);
  sym(1).Node = node;
} break;

#line 2791 "qmljs.g"

case 324: {
  sym(1).Node = 0;
} break;

#line 2798 "qmljs.g"

case 325: {
  sym(1).Node = sym(1).FormalParameterList->finish ();
} break;

#line 2805 "qmljs.g"

case 326: {
  sym(1).Node = 0;
} break;

#line 2814 "qmljs.g"

case 328: {
  sym(1).Node = makeAstNode<AST::FunctionBody> (driver->nodePool(), sym(1).SourceElements->finish ());
} break;

#line 2829 "qmljs.g"

case 329: {
  sym(1).Node = makeAstNode<AST::SourceElements> (driver->nodePool(), sym(1).SourceElement);
} break;

#line 2836 "qmljs.g"

case 330: {
  sym(1).Node = makeAstNode<AST::SourceElements> (driver->nodePool(), sym(1).SourceElements, sym(2).SourceElement);
} break;

#line 2843 "qmljs.g"

case 331: {
  sym(1).Node = makeAstNode<AST::StatementSourceElement> (driver->nodePool(), sym(1).Statement);
} break;

#line 2850 "qmljs.g"

case 332: {
  sym(1).Node = makeAstNode<AST::FunctionSourceElement> (driver->nodePool(), sym(1).FunctionDeclaration);
} break;

#line 2857 "qmljs.g"

case 333: {
  sym(1).sval = 0;
} break;

#line 2866 "qmljs.g"

case 335: {
  sym(1).Node = 0;
} break;

#line 2874 "qmljs.g"

            } // switch
            action = nt_action(state_stack[tos], lhs[r] - TERMINAL_COUNT);
        } // if
    } while (action != 0);

    if (first_token == last_token) {
        const int errorState = state_stack[tos];

        // automatic insertion of `;'
        if (t_action(errorState, T_AUTOMATIC_SEMICOLON) && automatic(driver, yytoken)) {
            SavedToken &tk = token_buffer[0];
            tk.token = yytoken;
            tk.dval = yylval;
            tk.loc = yylloc;

            yylloc = yyprevlloc;
            yylloc.offset += yylloc.length;
            yylloc.startColumn += yylloc.length;
            yylloc.length = 0;

            //const QString msg = QString::fromUtf8("Missing `;'");
            //diagnostic_messages.append(DiagnosticMessage(DiagnosticMessage::Warning, yylloc, msg));

            first_token = &token_buffer[0];
            last_token = &token_buffer[1];

            yytoken = T_SEMICOLON;
            yylval = 0;

            action = errorState;

            goto _Lcheck_token;
        }

        hadErrors = true;

        token_buffer[0].token = yytoken;
        token_buffer[0].dval = yylval;
        token_buffer[0].loc = yylloc;

        token_buffer[1].token = yytoken = lexer->lex();
        token_buffer[1].dval  = yylval  = lexer->dval();
        token_buffer[1].loc   = yylloc  = location(lexer);

        if (t_action(errorState, yytoken)) {
            const QString msg = QString::fromUtf8("Unexpected token `%1'").arg(QLatin1String(spell[token_buffer[0].token]));
            diagnostic_messages.append(DiagnosticMessage(DiagnosticMessage::Error, token_buffer[0].loc, msg));

            action = errorState;
            goto _Lcheck_token;
        }

        static int tokens[] = {
            T_PLUS,
            T_EQ,

            T_COMMA,
            T_COLON,
            T_SEMICOLON,

            T_RPAREN, T_RBRACKET, T_RBRACE,

            T_NUMERIC_LITERAL,
            T_IDENTIFIER,

            T_LPAREN, T_LBRACKET, T_LBRACE,

            EOF_SYMBOL
        };

        for (int *tk = tokens; *tk != EOF_SYMBOL; ++tk) {
            int a = t_action(errorState, *tk);
            if (a > 0 && t_action(a, yytoken)) {
                const QString msg = QString::fromUtf8("Expected token `%1'").arg(QLatin1String(spell[*tk]));
                diagnostic_messages.append(DiagnosticMessage(DiagnosticMessage::Error, token_buffer[0].loc, msg));

                yytoken = *tk;
                yylval = 0;
                yylloc = token_buffer[0].loc;
                yylloc.length = 0;

                first_token = &token_buffer[0];
                last_token = &token_buffer[2];

                action = errorState;
                goto _Lcheck_token;
            }
        }

        for (int tk = 1; tk < TERMINAL_COUNT; ++tk) {
            if (tk == T_AUTOMATIC_SEMICOLON)
               continue;

            int a = t_action(errorState, tk);
            if (a > 0 && t_action(a, yytoken)) {
                const QString msg = QString::fromUtf8("Expected token `%1'").arg(QLatin1String(spell[tk]));
                diagnostic_messages.append(DiagnosticMessage(DiagnosticMessage::Error, token_buffer[0].loc, msg));

                yytoken = tk;
                yylval = 0;
                yylloc = token_buffer[0].loc;
                yylloc.length = 0;

                action = errorState;
                goto _Lcheck_token;
            }
        }

        const QString msg = QString::fromUtf8("Syntax error");
        diagnostic_messages.append(DiagnosticMessage(DiagnosticMessage::Error, token_buffer[0].loc, msg));
    }

    return false;
}

QT_END_NAMESPACE


