/*
 * THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT.
 *
 *
 * Copyright (C) 2005 Apple Computer, Inc.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 */


#include "config.h"
#include "SVGElementFactory.h"

#include "SVGNames.h"
#if ENABLE(DASHBOARD_SUPPORT)
#include "Document.h"
#include "Settings.h"
#endif

#include "SVGAElement.h"
#include "SVGAltGlyphElement.h"
#include "SVGAnimateElement.h"
#include "SVGAnimateColorElement.h"
#include "SVGAnimateMotionElement.h"
#include "SVGAnimateTransformElement.h"
#include "SVGCircleElement.h"
#include "SVGClipPathElement.h"
#include "SVGCursorElement.h"
#include "SVGDefinitionSrcElement.h"
#include "SVGDefsElement.h"
#include "SVGDescElement.h"
#include "SVGEllipseElement.h"
#include "SVGFontElement.h"
#include "SVGFontFaceElement.h"
#include "SVGFontFaceFormatElement.h"
#include "SVGFontFaceNameElement.h"
#include "SVGFontFaceSrcElement.h"
#include "SVGFontFaceUriElement.h"
#include "SVGForeignObjectElement.h"
#include "SVGGElement.h"
#include "SVGGlyphElement.h"
#include "SVGHKernElement.h"
#include "SVGImageElement.h"
#include "SVGLineElement.h"
#include "SVGLinearGradientElement.h"
#include "SVGMarkerElement.h"
#include "SVGMaskElement.h"
#include "SVGMetadataElement.h"
#include "SVGMissingGlyphElement.h"
#include "SVGMPathElement.h"
#include "SVGPathElement.h"
#include "SVGPatternElement.h"
#include "SVGPolygonElement.h"
#include "SVGPolylineElement.h"
#include "SVGRadialGradientElement.h"
#include "SVGRectElement.h"
#include "SVGScriptElement.h"
#include "SVGSetElement.h"
#include "SVGStopElement.h"
#include "SVGStyleElement.h"
#include "SVGSVGElement.h"
#include "SVGSwitchElement.h"
#include "SVGSymbolElement.h"
#include "SVGTextElement.h"
#include "SVGTextPathElement.h"
#include "SVGTitleElement.h"
#include "SVGTRefElement.h"
#include "SVGTSpanElement.h"
#include "SVGUseElement.h"
#include "SVGViewElement.h"
#include <wtf/HashMap.h>

namespace WebCore {

using namespace SVGNames;

typedef PassRefPtr<SVGElement> (*ConstructorFunction)(const QualifiedName&, Document*, bool createdByParser);
typedef HashMap<AtomicStringImpl*, ConstructorFunction> FunctionMap;

static FunctionMap* gFunctionMap = 0;

#if ENABLE(SVG)
static PassRefPtr<SVGElement> aConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGAElement(tagName, doc);
}

static PassRefPtr<SVGElement> altglyphConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGAltGlyphElement(tagName, doc);
}

static PassRefPtr<SVGElement> animateConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGAnimateElement(tagName, doc);
}

static PassRefPtr<SVGElement> animatecolorConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGAnimateColorElement(tagName, doc);
}

static PassRefPtr<SVGElement> animatemotionConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGAnimateMotionElement(tagName, doc);
}

static PassRefPtr<SVGElement> animatetransformConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGAnimateTransformElement(tagName, doc);
}

static PassRefPtr<SVGElement> circleConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGCircleElement(tagName, doc);
}

static PassRefPtr<SVGElement> clippathConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGClipPathElement(tagName, doc);
}

static PassRefPtr<SVGElement> cursorConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGCursorElement(tagName, doc);
}

static PassRefPtr<SVGElement> definitionsrcConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGDefinitionSrcElement(tagName, doc);
}

static PassRefPtr<SVGElement> defsConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGDefsElement(tagName, doc);
}

static PassRefPtr<SVGElement> descConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGDescElement(tagName, doc);
}

static PassRefPtr<SVGElement> ellipseConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGEllipseElement(tagName, doc);
}

static PassRefPtr<SVGElement> fontConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGFontElement(tagName, doc);
}

static PassRefPtr<SVGElement> fontfaceConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGFontFaceElement(tagName, doc);
}

static PassRefPtr<SVGElement> fontfaceformatConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGFontFaceFormatElement(tagName, doc);
}

static PassRefPtr<SVGElement> fontfacenameConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGFontFaceNameElement(tagName, doc);
}

static PassRefPtr<SVGElement> fontfacesrcConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGFontFaceSrcElement(tagName, doc);
}

static PassRefPtr<SVGElement> fontfaceuriConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGFontFaceUriElement(tagName, doc);
}

static PassRefPtr<SVGElement> foreignobjectConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGForeignObjectElement(tagName, doc);
}

static PassRefPtr<SVGElement> gConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGGElement(tagName, doc);
}

static PassRefPtr<SVGElement> glyphConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGGlyphElement(tagName, doc);
}

static PassRefPtr<SVGElement> hkernConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGHKernElement(tagName, doc);
}

static PassRefPtr<SVGElement> imageConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGImageElement(tagName, doc);
}

static PassRefPtr<SVGElement> lineConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGLineElement(tagName, doc);
}

static PassRefPtr<SVGElement> lineargradientConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGLinearGradientElement(tagName, doc);
}

static PassRefPtr<SVGElement> markerConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGMarkerElement(tagName, doc);
}

static PassRefPtr<SVGElement> maskConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGMaskElement(tagName, doc);
}

static PassRefPtr<SVGElement> metadataConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGMetadataElement(tagName, doc);
}

static PassRefPtr<SVGElement> missingglyphConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGMissingGlyphElement(tagName, doc);
}

static PassRefPtr<SVGElement> mpathConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGMPathElement(tagName, doc);
}

static PassRefPtr<SVGElement> pathConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGPathElement(tagName, doc);
}

static PassRefPtr<SVGElement> patternConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGPatternElement(tagName, doc);
}

static PassRefPtr<SVGElement> polygonConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGPolygonElement(tagName, doc);
}

static PassRefPtr<SVGElement> polylineConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGPolylineElement(tagName, doc);
}

static PassRefPtr<SVGElement> radialgradientConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGRadialGradientElement(tagName, doc);
}

static PassRefPtr<SVGElement> rectConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGRectElement(tagName, doc);
}

static PassRefPtr<SVGElement> scriptConstructor(const QualifiedName& tagName, Document* doc, bool createdByParser)
{
    return new SVGScriptElement(tagName, doc, createdByParser);
}

static PassRefPtr<SVGElement> setConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGSetElement(tagName, doc);
}

static PassRefPtr<SVGElement> stopConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGStopElement(tagName, doc);
}

static PassRefPtr<SVGElement> styleConstructor(const QualifiedName& tagName, Document* doc, bool createdByParser)
{
    return new SVGStyleElement(tagName, doc, createdByParser);
}

static PassRefPtr<SVGElement> svgConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGSVGElement(tagName, doc);
}

static PassRefPtr<SVGElement> switchConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGSwitchElement(tagName, doc);
}

static PassRefPtr<SVGElement> symbolConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGSymbolElement(tagName, doc);
}

static PassRefPtr<SVGElement> textConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGTextElement(tagName, doc);
}

static PassRefPtr<SVGElement> textpathConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGTextPathElement(tagName, doc);
}

static PassRefPtr<SVGElement> titleConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGTitleElement(tagName, doc);
}

static PassRefPtr<SVGElement> trefConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGTRefElement(tagName, doc);
}

static PassRefPtr<SVGElement> tspanConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGTSpanElement(tagName, doc);
}

static PassRefPtr<SVGElement> useConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGUseElement(tagName, doc);
}

static PassRefPtr<SVGElement> viewConstructor(const QualifiedName& tagName, Document* doc, bool)
{
    return new SVGViewElement(tagName, doc);
}

#endif
#if ENABLE(SVG)
static void addTag(const QualifiedName& tag, ConstructorFunction func)
{
    gFunctionMap->set(tag.localName().impl(), func);
}

static inline void createFunctionMapIfNecessary()
{
    if (gFunctionMap)
        return;
    // Create the table.
    gFunctionMap = new FunctionMap;
    
    // Populate it with constructor functions.
    addTag(aTag, aConstructor);
    addTag(altGlyphTag, altglyphConstructor);
    addTag(animateTag, animateConstructor);
    addTag(animateColorTag, animatecolorConstructor);
    addTag(animateMotionTag, animatemotionConstructor);
    addTag(animateTransformTag, animatetransformConstructor);
    addTag(circleTag, circleConstructor);
    addTag(clipPathTag, clippathConstructor);
    addTag(cursorTag, cursorConstructor);
    addTag(definition_srcTag, definitionsrcConstructor);
    addTag(defsTag, defsConstructor);
    addTag(descTag, descConstructor);
    addTag(ellipseTag, ellipseConstructor);
    addTag(fontTag, fontConstructor);
    addTag(font_faceTag, fontfaceConstructor);
    addTag(font_face_formatTag, fontfaceformatConstructor);
    addTag(font_face_nameTag, fontfacenameConstructor);
    addTag(font_face_srcTag, fontfacesrcConstructor);
    addTag(font_face_uriTag, fontfaceuriConstructor);
    addTag(foreignObjectTag, foreignobjectConstructor);
    addTag(gTag, gConstructor);
    addTag(glyphTag, glyphConstructor);
    addTag(hkernTag, hkernConstructor);
    addTag(imageTag, imageConstructor);
    addTag(lineTag, lineConstructor);
    addTag(linearGradientTag, lineargradientConstructor);
    addTag(markerTag, markerConstructor);
    addTag(maskTag, maskConstructor);
    addTag(metadataTag, metadataConstructor);
    addTag(missing_glyphTag, missingglyphConstructor);
    addTag(mpathTag, mpathConstructor);
    addTag(pathTag, pathConstructor);
    addTag(patternTag, patternConstructor);
    addTag(polygonTag, polygonConstructor);
    addTag(polylineTag, polylineConstructor);
    addTag(radialGradientTag, radialgradientConstructor);
    addTag(rectTag, rectConstructor);
    addTag(scriptTag, scriptConstructor);
    addTag(setTag, setConstructor);
    addTag(stopTag, stopConstructor);
    addTag(styleTag, styleConstructor);
    addTag(svgTag, svgConstructor);
    addTag(switchTag, switchConstructor);
    addTag(symbolTag, symbolConstructor);
    addTag(textTag, textConstructor);
    addTag(textPathTag, textpathConstructor);
    addTag(titleTag, titleConstructor);
    addTag(trefTag, trefConstructor);
    addTag(tspanTag, tspanConstructor);
    addTag(useTag, useConstructor);
    addTag(viewTag, viewConstructor);
}
#endif

PassRefPtr<SVGElement> SVGElementFactory::createSVGElement(const QualifiedName& qName, Document* doc, bool createdByParser)
{
#if ENABLE(SVG)
    // Don't make elements without a document
    if (!doc)
        return 0;

#if ENABLE(DASHBOARD_SUPPORT)
    Settings* settings = doc->settings();
    if (settings && settings->usesDashboardBackwardCompatibilityMode())
        return 0;
#endif
    createFunctionMapIfNecessary();
    ConstructorFunction func = gFunctionMap->get(qName.localName().impl());
    if (func)
        return func(qName, doc, createdByParser);
    return new SVGElement(qName, doc);
#else
    return 0;
#endif
}

} // namespace WebCore

