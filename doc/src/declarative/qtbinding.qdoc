/****************************************************************************
**
** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
** Contact: Qt Software Information (qt-info@nokia.com)
**
** This file is part of the documentation of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:LGPL$
** No Commercial Usage
** This file contains pre-release code and may not be distributed.
** You may use this file in accordance with the terms and conditions
** contained in the either Technology Preview License Agreement or the
** Beta Release License Agreement.
**
** GNU Lesser General Public License Usage
** Alternatively, this file may be used under the terms of the GNU Lesser
** General Public License version 2.1 as published by the Free Software
** Foundation and appearing in the file LICENSE.LGPL included in the
** packaging of this file.  Please review the following information to
** ensure the GNU Lesser General Public License version 2.1 requirements
** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
** In addition, as a special exception, Nokia gives you certain
** additional rights. These rights are described in the Nokia Qt LGPL
** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
** package.
**
** GNU General Public License Usage
** Alternatively, this file may be used under the terms of the GNU
** General Public License version 3.0 as published by the Free Software
** Foundation and appearing in the file LICENSE.GPL included in the
** packaging of this file.  Please review the following information to
** ensure the GNU General Public License version 3.0 requirements will be
** met: http://www.gnu.org/copyleft/gpl.html.
**
** If you are unsure which license is appropriate for your use, please
** contact the sales department at qt-sales@nokia.com.
** $QT_END_LICENSE$
**
****************************************************************************/

/*!
\page qtbinding.html
\target qtbinding
\title Using QML in C++ Applications

The QML API is split into three main classes - QmlEngine, QmlComponent and QmlContext.  
QmlEngine provides the environment in which QML is run, QmlComponent encapsulates 
\l {QML Documents}, and QmlContext allows applications to expose data to QML component instances.

\section1 Basic Usage

Every application requires at least one QmlEngine.  A QmlEngine allows the configuration of
global settings that apply to all the QML component instances - such as the QNetworkAccessManager
that is used for network communications, and the path used for persistent storage.  
Multiple QmlEngine's are only needed if the application requires these settings to differ 
between QML component instances.

\l {QML Documents} are loaded using the QmlComponent class.  Each QmlComponent instance 
represents a single QML document.  A QmlComponent can be passed a document URL, or raw text
representing the content of the document.  The document URL can be a local filesystem URL, or
any network URL supported by QNetworkAccessManager.

QML component instances can then be created by calling the QmlComponent::create() method.  Here's
an example of loading a QML document, and creating an object from it.

\code
QmlEngine *engine = new QmlEngine(parent);
QmlComponent component(engine, QUrl("main.qml"));
QObject *myObject = component.create();
\endcode

\section1 Exposing Data

QML components are instantiated in a QmlContext.  A context allows the application to expose data
to the QML component instance.  A single QmlContext can be used to instantiate all the objects
used by an application, or several QmlContext can be created for more fine grained control over
the data exposed to each instance.  If a context is not passed to the QmlComponent::create()
method, the QmlEngine's \l {QmlEngine::rootContext()}{root context} is used.

To expose data to a QML component instance, applications set \l {QmlContext::setContextProperty()}{context properties} which are then accessible by name from QML  \l {Property Binding}s and 
\l {ECMAScript Blocks}.

\section1 Network Components

If the URL passed to QmlComponent is a network resource, or if the QML document references a
network resource, the QmlComponent has to fetch the network data before it is able to create
objects.  In this case, the QmlComponent will have a \l {QmlComponent::Loading}{Loading}
\l {QmlComponent::status()}{status}.  An application will have to wait until the component
is \l {QmlComponent::Ready}{Ready} before calling \l {QmlComponent::create()}.

The following example shows how to load a QML file from a network resource.  After creating
the QmlComponent, it tests whether the component is loading.  If it is, it connects to the
QmlComponent::statusChanged() signal and otherwise calls the \c {continueLoading()} method
directly.  This test is necessary, even for URLs that are known to be remote, just in case
the component has been cached and is ready immediately.

\code
MyApplication::MyApplication()
{
    // ...
    component = new QmlComponent(engine, QUrl("http://www.example.com/main.qml"));
    if (component->isLoading())
        QObject::connect(component, SIGNAL(statusChanged(QmlComponent::Status)),
                         this, SLOT(continueLoading()));
    else
        continueLoading();
}

void MyApplication::continueLoading()
{
    if (component->isError()) {
        qWarning() << component->errors();
    } else {
        QObject *myObject = component->create();
    }
}
\endcode

\section1 TODO
\list
\o QmlEngine and QmlComponent
\o QmlContext and data
\o QBindableMap
\o QAbstractItemModel Data models
\o QmlView
\endlist

*/

/*
\section1 Overview

The QML mechanisms of data binding can also be used to bind Qt C++ objects.

The data binding framework is based on Qt's property system (see the Qt documentation for more details on this system). If a binding is meant to be dynamic (where changes in one object are reflected in another object), \c NOTIFY must be specified for the property being tracked. If \c NOTIFY is not specified, any binding to that property will be an 'intialization' binding (the tracking object will be updated only once with the initial value of the tracked object).

Relevant items can also be bound to the contents of a Qt model.
For example, ListView can make use of data from a QAbstractItemModel-derived model.

\section1 Passing Data Between C++ and QML

Data binding provides one method of data transfer between C++ and QML.

For example, lets say you want to implement a slider in QML that changes the screen brightness of the device it is running on. You would start by declaring a brightness property on your QObject-derived class:
\code
class MyScreen : public QObject
{
    Q_OBJECT
public:
    MyScreen(QObject *parent=0);

    Q_PROPERTY(int brightness READ brightness WRITE setBrightness NOTIFY brightnessChanged);
    int brightness() const;
    void setBrightness(int b);
    ...

signals:
    void brightnessChanged();

private:
    int m_brightness;
};

int brightness() const
{
    return m_brightness;
}

void setBrightness(int b)
{
    if (b != m_brightness) {
        m_brightness = b;
        emit brightnessChanged();

        //set device brightness
        ...
    }
}
\endcode

\note One important thing to keep in mind is that the changed signal should only be emitted when there is a real change ( \c b \c != \c m_brightness ), or you may get an infinite loop.

Next, make an instance of this class visible to the QML bind engine:
\code
QmlView *view = new QmlView;
view->setUrl("MyUI.qml");

MyScreen *screen = new MyScreen;
QmlContext *ctxt = view->rootContext();
ctxt->setContextProperty("screen", screen);

view->execute();
\endcode

\note Bindings must be made after setUrl() but before execute().

Finally, in QML you can make the appropriate bindings, so in \c "MyUI.qml":

\code
Slider { value: screen.brightness }
Binding { target: screen; property: "brightness"; value: slider.value }
\endcode

The \l QBindableMap class provides a convenient way to make data visible to the bind engine.

C++ \l {qmlmodels}{Data Models} may also be provided to QML.

*/
